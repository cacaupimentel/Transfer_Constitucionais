f_Relatorio_FOCUS


let
    Fonte = Python.Execute("#(lf)import pandas as pd#(lf)import numpy as np#(lf)#(lf)import os#(lf)import requests#(lf)#(lf)from collections import OrderedDict#(lf)from datetime import date#(lf)from dateutil.relativedelta import relativedelta#(lf)#(lf)#(lf)#(lf)# Funçao de comparação de strings#(lf)def isEqual(a, b):#(lf)  # Premissa de que sejam iguais#(lf)  igual = True#(lf)#(lf)  # Primeiro obtem tamanhos#(lf)  a = str(a)#(lf)  b = str(b)#(lf)#(lf)  lena = len(a)#(lf)  lenb = len(b)#(lf)  if lena > lenb or lenb > lena:#(lf)      igual = False#(lf)#(lf)  # print('len a', lenA)#(lf)  # print('len b', lenB)#(lf)  # se passo dos comandos testar#(lf)  if igual:#(lf)    # ja que os tamanhos são iguais vamos verrer caracter#(lf)    # por caracter pelo tamnho de A#(lf)    for i in range(lena):#(lf)      # print(a[i:i+1], "" = "", b[i:i+1])#(lf)      if a[i:i+1] != b[i:i+1]:#(lf)          # print(""Diferente"")#(lf)          igual = False#(lf)          break#(lf)#(lf)  return igual#(lf)#(lf)#(lf)## ""https://olinda.bcb.gov.br/olinda/servico/Expectativas/versao/v1/odata/ExpectativaMercadoMensais?&$format=json&$select=Indicador,Data,DataReferencia,Mediana""#(lf)#(lf)## ""https://olinda.bcb.gov.br/olinda/servico/Expectativas/versao/v1/odata/#(lf)# ExpectativaMercadoMensais#(lf)# ?&$format=json#(lf)# &$select=Indicador,Data,DataReferencia,Mediana""#(lf)#(lf)def Cria_URL_BCB_olinda(udtini, udtfim, stabela, scampos):#(lf)  # String de pesquisa da url#(lf)  s = """"#(lf)  s =  stabela#(lf)  s = s + ""?&$format=json"" #(lf)  s = s + ""&$select="" + scampos#(lf)  s = s + ""&dataInicial="" + udtini#(lf)  s = s + ""&dataFinal="" + udtfim#(lf)  #(lf)  # Monta base da consulta#(lf)  url = ""https://olinda.bcb.gov.br/olinda/servico/Expectativas/versao/v1/odata/"" + s#(lf)#(lf)  #print(""Tabela BCB: "", stabela)#(lf)  #print('------------------------------------------------------------------------------------')#(lf)  #print(""webdriver gets url...."")#(lf)  #print(url)#(lf)#(lf)  return url#(lf)#(lf)#(lf)#(lf)### Variáveis globais para trazer apenas as expectativas mais recentes#(lf)# Da Data Atual, subtrai 2 meses colocando, pois o banco publica sempre depois de 2 meses#(lf)mardata = (date.today() + relativedelta(years=4)).replace(day=1) #(lf)maiordata =  date.strftime(mardata, format=""%m/%d/%Y"")#(lf)#print('Maior Data: ', maiordata)#(lf)#(lf)# Esta data deve ficar fixa pois é a menor que a consulta disponibiliza ""MM/dd/yyyy""#(lf)meodata = (date.today() + relativedelta(months=-1)).replace(day=1) #(lf)menordata =  date.strftime(meodata, format=""%m/%d/%Y"")#(lf)#print('Menor Data: ',maiordata)#(lf)#(lf)caminho = ""C:/Users/cacau/Documents/MESTRADO/DISSERTACAO/Dados_Abertos"" #(lf)#(lf)#(lf)# Pega o Caminho já definido#(lf)#caminho = dataset['Caminho'][0]#(lf)#(lf)# Seleciona o caminho do Arquivo#(lf)basedir = caminho + ""/Banco_Central_do_Brasil/FOCUS/""#(lf)#(lf)# Nome do arquivo#(lf)nomearq = ""f_FOCUS.csv""#(lf)#(lf)# cria um diretório para armazenar o arquivo comparâmetro para não criar se já existir#(lf)os.makedirs(os.path.abspath(os.path.dirname(basedir)), exist_ok=True)#(lf)#(lf)basedir = os.path.abspath(os.path.dirname(basedir))#(lf)#(lf)# Apaga o arquivo se foi criado#(lf)if os.path.isfile(os.path.join(basedir, nomearq)):#(lf)  # Se existe apaga o arquivo#(lf)  os.remove(os.path.join(basedir, nomearq))#(lf)#(lf)#(lf)# Abre o arquivo csv#(lf)#arq_csv = open(""Belem.csv"",""w"",encoding=""utf-8"")#(lf)#tmp = """"#(lf)#tmp = tmp + ""coodigoIBGE,"" + ""mes,"" + ""ano,"" + ""descricao,"" + ""fonte,""#(lf)#tmp = tmp + ""aplicacao,"" + ""valorOrcadoAtualizado,"" + ""valorOrcado,""#(lf)#tmp = tmp + ""valorArrecadado""#(lf)#(lf)##arq_csv.write(tmp + '\n')#(lf)#(lf)i = 0#(lf)#(lf)Registros = []#(lf)#(lf)# Garda na variável a resposta para o método GET do site#(lf)#resposta = requests.get(""https://olinda.bcb.gov.br/olinda/servico/Expectativas/versao/v1/odata/ExpectativaMercadoMensais?&$format=json&$select=Indicador,Data,DataReferencia,Mediana"")#(lf)urls = Cria_URL_BCB_olinda(menordata, maiordata, ""ExpectativaMercadoMensais"", ""Indicador,Data,DataReferencia,Mediana"")#(lf)#(lf)resposta = requests.get(urls)#(lf)arq_json = resposta.json()#(lf)#(lf)obj = dict(arq_json)#(lf)values = obj.get(""value"")#(lf)#(lf)for l in values:#(lf)#(lf)  object = dict(l)#(lf)  indicador = l.get(""Indicador"")#(lf)  Data = l.get(""Data"")#(lf)  DataReferencia = ""15/"" + l.get(""DataReferencia"")#(lf)  Mediana = l.get(""Mediana"")#(lf)#(lf)  # Adiciona a lista#(lf)  Registros.append([indicador, Data, DataReferencia, Mediana])#(lf)  #print(indicador, Data, DataReferencia, Mediana)#(lf)#(lf)#(lf)# Criando o dataset#(lf)dataset = pd.DataFrame(Registros, columns=['Idicador', 'Data','DataReferencia', 'Mediana'])#(lf)#(lf)# Salva o arquivo na Pasta de unificação#(lf)dataset[['Idicador', 'Data','DataReferencia', 'Mediana']].to_csv(os.path.join(basedir, nomearq), index = False, sep =';')#(lf)#(lf)print(dataset)"),
    dataset1 = Fonte{[Name="dataset"]}[Value],
    #"Valor Substituído" = Table.ReplaceValue(dataset1,".",",",Replacer.ReplaceText,{"Mediana"}),
    #"Tipo Alterado" = Table.TransformColumnTypes(#"Valor Substituído",{{"Idicador", type text}, {"Data", type date}, {"DataReferencia", type date}, {"Mediana", type number}}),
    #"Filtra os nulos" = Table.SelectRows(#"Tipo Alterado", each [Mediana] <> null and [Mediana] <> ""),
    #"Linhas Filtradas" = Table.SelectRows(#"Filtra os nulos", each [Data] > #date(2021, 12, 1)),
    #"Coluna em pivô" = Table.Pivot(#"Linhas Filtradas", List.Distinct(#"Linhas Filtradas"[Idicador]), "Idicador", "Mediana", List.Max),
    #"Linhas Classificadas" = Table.Sort(#"Coluna em pivô",{{"Data", Order.Ascending}}),
    #"Preenchido Abaixo" = Table.FillDown(#"Linhas Classificadas", Table.ColumnNames(#"Linhas Classificadas")),
    #"Linhas Nulas Filtradas" = Table.SelectRows(#"Preenchido Abaixo", each ([IPCA] <> null)),
    #"Cria Col Caminho" = Table.AddColumn(#"Linhas Nulas Filtradas", "Caminho", each Caminho),
    #"Tipo Alterado p/Texto" = Table.TransformColumnTypes(#"Cria Col Caminho",{{"Data", type text}, {"DataReferencia", type text}, {"Caminho", type text}}),
    #"Colunas Renomeadas" = Table.RenameColumns(#"Tipo Alterado p/Texto",{{"Taxa de desocupação", "TaxaDesocupacao"}, {"IPCA Alimentação no domicílio", "IPCA_AlimentacaoDomicilio"}, {"IPCA Administrados", "IPCA_Administrados"}, {"IPCA Bens industrializados", "IPCA_BensIndustrializados"}, {"IPCA Serviços", "IPCA_Servicos"}, {"IPCA Livres", "IPCA_Livres"}, {"Câmbio", "Cambio"}}),
    #"Executar script Python" = Python.Execute("# 'dataset' tem os dados de entrada para este script#(lf)# -*- encoding: utf-8 -*-#(lf)import pandas as pd#(lf)import os#(lf)from datetime import date#(lf)#(lf)# Pega o Caminho já definido#(lf)Caminho = dataset['Caminho'][0]#(lf)#(lf)# Seleciona o caminho do Arquivo#(lf)basedir = Caminho + ""/ArquivosParaUnificar/""#(lf)#(lf)# Nome do arquivo#(lf)nomearq = ""f_Relatorio_FOCUS.csv""#(lf)#(lf)# cria um diretório para armazenar o arquivo comparâmetro para não criar se já existir#(lf)os.makedirs(os.path.abspath(os.path.dirname(basedir)), exist_ok=True)#(lf)#(lf)basedir = os.path.abspath(os.path.dirname(basedir))#(lf)#(lf)# Apaga o arquivo se foi criado#(lf)if os.path.isfile(os.path.join(basedir, nomearq)):#(lf)  # Se existe apaga o arquivo#(lf)  os.remove(os.path.join(basedir, nomearq))#(lf)#(lf)# Salva o arquivo na Pasta de unificação#(lf)dataset.to_csv(os.path.join(basedir, nomearq), index = False, sep =';')#(lf)#(lf)print(dataset)",[dataset=#"Colunas Renomeadas"]),
    dataset = #"Executar script Python"{[Name="dataset"]}[Value],
    #"Tipo Alterado1" = Table.TransformColumnTypes(dataset,{{"DataReferencia", type date}, {"Data", type date}}),
    #"Colunas Removidas" = Table.RemoveColumns(#"Tipo Alterado1",{"Caminho"})
in
    #"Colunas Removidas"


METADADOS:


